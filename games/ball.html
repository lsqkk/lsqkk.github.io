<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手机平板托乒乓球</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #f5f5f5; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #tip { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: #333; font-size: 16px; text-align: center; }
    </style>
</head>
<body>
    <div id="tip">点击屏幕激活陀螺仪，倾斜手机控制平板托球～</div>
    <canvas id="gameCanvas"></canvas>

    <!-- 引入Cannon.js物理引擎 -->
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>
    <script>
        // 1. 初始化Canvas和上下文
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // 2. 初始化Cannon.js物理世界
        const world = new CANNON.World();
        world.gravity.set(0, -9.8, 0); // 重力方向（Y轴负方向）
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.solver.iterations = 15; // 碰撞精度
        world.solver.tolerance = 0.001;

        // 3. 创建物理材质（控制摩擦和弹性）
        const groundMaterial = new CANNON.Material('groundMaterial');
        const ballMaterial = new CANNON.Material('ballMaterial');
        const contactMaterial = new CANNON.ContactMaterial(
            groundMaterial,
            ballMaterial,
            {
                friction: 0.1, // 摩擦系数（越小球越滑）
                restitution: 0.3, // 弹性系数（越小球越不弹）
                contactEquationStiffness: 1000,
                contactEquationRelaxation: 4
            }
        );
        world.addContactMaterial(contactMaterial);

        // 4. 创建"平板"物理体（静止，质量为0）
        const groundSize = { width: 8, height: 6 }; // 平板物理尺寸
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({
            mass: 0, // 质量为0表示固定不动
            material: groundMaterial,
            quaternion: new CANNON.Quaternion().setFromEuler(-Math.PI/2, 0, 0) // 旋转为水平
        });
        groundBody.addShape(groundShape, new CANNON.Vec3(0, 0, 0));
        groundBody.position.set(0, -2, 0); // 平板初始位置
        world.addBody(groundBody);

        // 5. 创建乒乓球物理体
        const ballRadius = 0.3;
        const ballShape = new CANNON.Sphere(ballRadius);
        const ballBody = new CANNON.Body({
            mass: 0.1, // 球的质量
            material: ballMaterial,
            linearDamping: 0.05, // 空气阻力（减小抖动）
            angularDamping: 0.1
        });
        ballBody.addShape(ballShape);
        ballBody.position.set(0, 1, 0); // 球初始位置（平板上方）
        world.addBody(ballBody);

        // 6. 陀螺仪数据处理（核心：将设备倾斜转为平板角度）
        let beta = 0; // 前后倾斜角度（-180~180）
        let gamma = 0; // 左右倾斜角度（-90~90）
        const tiltSensitivity = 0.8; // 倾斜灵敏度（越小越平缓）

        // 点击屏幕激活陀螺仪（iOS必须用户交互触发）
        document.body.addEventListener('click', initGyro, { once: true });
        function initGyro() {
            document.getElementById('tip').textContent = '倾斜手机控制平板，别让球掉下去！';
            if (window.DeviceOrientationEvent) {
                // 监听设备方向变化
                window.addEventListener('deviceorientation', (e) => {
                    // 限制角度范围，避免过度倾斜
                    beta = Math.max(-30, Math.min(30, e.beta || 0));
                    gamma = Math.max(-30, Math.min(30, e.gamma || 0));
                }, true);
            } else {
                alert('当前设备不支持陀螺仪功能，无法玩此游戏～');
            }
        }

        // 7. 更新平板倾斜角度
        function updatePlatformTilt() {
            // 将角度转为弧度，乘以灵敏度控制倾斜幅度
            const tiltX = gamma * tiltSensitivity * Math.PI / 180;
            const tiltY = beta * tiltSensitivity * Math.PI / 180;
            // 旋转平板（X轴控制左右倾斜，Y轴控制前后倾斜）
            groundBody.quaternion.setFromEuler(-Math.PI/2 + tiltY, tiltX, 0);
        }

        // 8. 物理世界与Canvas渲染同步
        function syncPhysicsToRender() {
            // 平板渲染（Canvas中心为原点，转换物理坐标到屏幕坐标）
            const groundScreenX = canvas.width / 2;
            const groundScreenY = canvas.height / 2;
            const groundRenderWidth = groundSize.width * 50; // 物理尺寸转屏幕像素
            const groundRenderHeight = groundSize.height * 50;

            // 乒乓球渲染坐标
            const ballScreenX = canvas.width / 2 + ballBody.position.x * 50;
            const ballScreenY = canvas.height / 2 - ballBody.position.y * 50; // Y轴反向（Canvas向下为正）
            const ballRenderRadius = ballRadius * 50;

            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 绘制平板（半透明矩形）
            ctx.save();
            ctx.translate(groundScreenX, groundScreenY);
            ctx.rotate(gamma * tiltSensitivity * Math.PI / 180); // 跟随倾斜旋转
            ctx.fillStyle = 'rgba(66, 133, 244, 0.7)';
            ctx.fillRect(-groundRenderWidth/2, -groundRenderHeight/2, groundRenderWidth, groundRenderHeight);
            ctx.restore();

            // 绘制乒乓球（黄色圆形）
            ctx.beginPath();
            ctx.arc(ballScreenX, ballScreenY, ballRenderRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#FFC107';
            ctx.fill();
            ctx.strokeStyle = '#FF9800';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 球掉出边界后重置位置
            if (Math.abs(ballBody.position.x) > groundSize.width/2 + ballRadius ||
                Math.abs(ballBody.position.y) > 5) {
                ballBody.position.set(0, 1, 0);
                ballBody.velocity.set(0, 0, 0);
                ballBody.angularVelocity.set(0, 0, 0);
            }
        }

        // 9. 动画循环（60帧/秒）
        function animate() {
            requestAnimationFrame(animate);
            updatePlatformTilt(); // 更新平板倾斜
            world.step(1/60); // 物理世界更新
            syncPhysicsToRender(); // 同步渲染
        }
        animate();
    </script>
</body>
</html>
