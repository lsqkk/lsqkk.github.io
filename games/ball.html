<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手机平板托乒乓球</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #f5f5f5; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #tip { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: #333; font-size: 16px; text-align: center; max-width: 90%; }
    </style>
</head>
<body>
    <div id="tip">正在启动陀螺仪...iOS请允许传感器权限</div>
    <canvas id="gameCanvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // 初始化物理世界
        const world = new CANNON.World();
        world.gravity.set(0, -9.8, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.solver.iterations = 15;
        world.solver.tolerance = 0.001;

        // 物理材质
        const groundMaterial = new CANNON.Material('groundMaterial');
        const ballMaterial = new CANNON.Material('ballMaterial');
        const contactMaterial = new CANNON.ContactMaterial(
            groundMaterial,
            ballMaterial,
            { friction: 0.1, restitution: 0.3, contactEquationStiffness: 1000, contactEquationRelaxation: 4 }
        );
        world.addContactMaterial(contactMaterial);

        // 创建平板
        const groundSize = { width: 8, height: 6 };
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({
            mass: 0,
            material: groundMaterial,
            quaternion: new CANNON.Quaternion().setFromEuler(-Math.PI/2, 0, 0)
        });
        groundBody.addShape(groundShape);
        groundBody.position.set(0, -2, 0);
        world.addBody(groundBody);

        // 创建乒乓球
        const ballRadius = 0.3;
        const ballShape = new CANNON.Sphere(ballRadius);
        const ballBody = new CANNON.Body({
            mass: 0.1,
            material: ballMaterial,
            linearDamping: 0.05,
            angularDamping: 0.1
        });
        ballBody.addShape(ballShape);
        ballBody.position.set(0, 1, 0);
        world.addBody(ballBody);

        // 陀螺仪变量
        let beta = 0;
        let gamma = 0;
        const tiltSensitivity = 0.8;

        // 页面加载后自动初始化陀螺仪（核心修改）
        window.addEventListener('load', initGyro);
        async function initGyro() {
            try {
                // 适配iOS 13+的权限请求
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        startOrientationListener();
                        document.getElementById('tip').textContent = '倾斜手机控制平板，别让球掉下去！';
                    } else {
                        document.getElementById('tip').textContent = '请开启传感器权限以正常游戏';
                    }
                } else {
                    // Android直接开启监听
                    startOrientationListener();
                    document.getElementById('tip').textContent = '倾斜手机控制平板，别让球掉下去！';
                }
            } catch (error) {
                document.getElementById('tip').textContent = '陀螺仪启动失败，请刷新重试';
                console.error(error);
            }
        }

        // 启动方向监听
        function startOrientationListener() {
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', (e) => {
                    beta = Math.max(-30, Math.min(30, e.beta || 0));
                    gamma = Math.max(-30, Math.min(30, e.gamma || 0));
                }, true);
            } else {
                document.getElementById('tip').textContent = '当前设备不支持陀螺仪功能';
            }
        }

        // 更新平板倾斜
        function updatePlatformTilt() {
            const tiltX = gamma * tiltSensitivity * Math.PI / 180;
            const tiltY = beta * tiltSensitivity * Math.PI / 180;
            groundBody.quaternion.setFromEuler(-Math.PI/2 + tiltY, tiltX, 0);
        }

        // 渲染同步
        function syncPhysicsToRender() {
            const groundScreenX = canvas.width / 2;
            const groundScreenY = canvas.height / 2;
            const groundRenderWidth = groundSize.width * 50;
            const groundRenderHeight = groundSize.height * 50;

            const ballScreenX = canvas.width / 2 + ballBody.position.x * 50;
            const ballScreenY = canvas.height / 2 - ballBody.position.y * 50;
            const ballRenderRadius = ballRadius * 50;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 绘制平板
            ctx.save();
            ctx.translate(groundScreenX, groundScreenY);
            ctx.rotate(gamma * tiltSensitivity * Math.PI / 180);
            ctx.fillStyle = 'rgba(66, 133, 244, 0.7)';
            ctx.fillRect(-groundRenderWidth/2, -groundRenderHeight/2, groundRenderWidth, groundRenderHeight);
            ctx.restore();

            // 绘制乒乓球
            ctx.beginPath();
            ctx.arc(ballScreenX, ballScreenY, ballRenderRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#FFC107';
            ctx.fill();
            ctx.strokeStyle = '#FF9800';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 球掉落重置
            if (Math.abs(ballBody.position.x) > groundSize.width/2 + ballRadius || Math.abs(ballBody.position.y) > 5) {
                ballBody.position.set(0, 1, 0);
                ballBody.velocity.set(0, 0, 0);
                ballBody.angularVelocity.set(0, 0, 0);
            }
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            updatePlatformTilt();
            world.step(1/60);
            syncPhysicsToRender();
        }
        animate();
    </script>
</body>
</html>
