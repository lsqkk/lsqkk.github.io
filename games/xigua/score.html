<!DOCTYPE html>
<html>
<head>
    <title>åˆæˆå¤§è¥¿ç“œ - åˆ†æ•°æ¨¡å¼</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: linear-gradient(160deg, #90e0ef 0%, #0077b6 100%);
            font-family: 'Arial Rounded MT Bold', Arial, sans-serif;
        }
        #stats {
            position: fixed;
            top: 20px;
            right: 20px;
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            text-align: right;
        }
        #preview {
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .game-over {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            color: white;
            text-align: center;
            border-radius: 10px;
            z-index: 100;
        }
        .game-over button {
            padding: 10px 20px;
            margin-top: 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #modeIndicator {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="modeIndicator">å½“å‰æ¨¡å¼ï¼šåˆ†æ•°æ¨¡å¼</div>
    <div id="stats">
        <div>å¾—åˆ†: <span id="score">0</span></div>
        <div>æ¬¡æ•°: <span id="clickCount">0</span></div>
        <div>å½“å‰å…³å¡: <span id="currentLevel">1</span></div>
        <div>ç›®æ ‡åˆ†æ•°: <span id="targetScore">600</span></div>
    </div>
    <div id="preview">
        <div>ä¸‹ä¸€ä¸ªæ°´æœ:</div>
        <div id="nextFruitPreview" style="font-size: 40px;"></div>
    </div>
    <div class="game-over" id="gameOver">
        <h2 id="gameOverText"></h2>
        <p>æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span></p>
        <p>æ€»æ¬¡æ•°: <span id="finalClickCount">0</span></p>
        <button onclick="location.reload()">å†ç©ä¸€æ¬¡</button>
    </div>

<script>
const FRUITS = [
    { name: 'ğŸ’', color: '#FF0000', radius: 20, score: 1 },
    { name: 'ğŸ“', color: '#FF1493', radius: 25, score: 3 },
    { name: 'ğŸ‡', color: '#9370DB', radius: 30, score: 6 },
    { name: 'ğŸŠ', color: '#FFA500', radius: 35, score: 10 },
    { name: 'ğŸ¥', color: '#9ACD32', radius: 40, score: 15 },
    { name: 'ğŸ…', color: '#FF4500', radius: 45, score: 21 },
    { name: 'ğŸ‘', color: '#FFB6C1', radius: 50, score: 28 },
    { name: 'ğŸ', color: '#FFD700', radius: 55, score: 36 },
    { name: 'ğŸ¥¥', color: '#8B4513', radius: 60, score: 45 },
    { name: 'ğŸ‰', color: '#228B22', radius: 65, score: 55 }
];

class ScoreModeGame {
    constructor() {
        this.engine = Matter.Engine.create();
        this.world = this.engine.world;
        this.render = Matter.Render.create({
            element: document.body,
            engine: this.engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: 'transparent',
                hasBounds: true
            }
        });

        // æ·»åŠ è‡ªå®šä¹‰æ¸²æŸ“é€»è¾‘
        Matter.Events.on(this.render, 'afterRender', () => {
            this.customRenderFruits();
        });

        this.maxFruitLevel = 0;
        this.score = 0;
        this.clickCount = 0;
        this.currentLevel = 1;
        this.targetScore = 600;
        this.gameOver = false;

        // åˆå§‹åŒ–ä¸‹ä¸€ä¸ªæ°´æœçš„ç±»å‹
        this.nextFruitType = this.getNextFruitType();

        this.initWorld();
        this.setupEvents();
        Matter.Runner.run(this.engine);
        Matter.Render.run(this.render);

        // åˆå§‹åŒ–ç»Ÿè®¡æ˜¾ç¤º
        this.updateStats();

        // åˆå§‹åŒ–é¢„è§ˆ
        this.updatePreview();

        // åŠ è½½æœ¬åœ°å­˜å‚¨çš„é€šå…³è®°å½•
        this.loadProgress();
    }

    customRenderFruits() {
        const context = this.render.context;
        const bodies = Matter.Composite.allBodies(this.world);

        bodies.forEach(body => {
            if (body.fruitType !== undefined) {
                const fruit = FRUITS[body.fruitType];
                const { x, y } = body.position;
                const radius = body.circleRadius;

                // ç»˜åˆ¶åœ†å½¢èƒŒæ™¯
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fillStyle = fruit.color;
                context.fill();
                context.closePath();

                // ç»˜åˆ¶æ°´æœå›¾æ ‡
                context.font = `${radius * 1.5}px Arial`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillStyle = '#fff';
                context.fillText(fruit.name, x, y);
            }
        });
    }

    initWorld() {
        // åˆ›å»ºè¾¹ç•Œ
        const ground = Matter.Bodies.rectangle(
            window.innerWidth/2, 
            window.innerHeight - 20,
            window.innerWidth, 
            40, 
            { isStatic: true, render: { visible: false } }
        );
        
        const leftWall = Matter.Bodies.rectangle(
            0, window.innerHeight/2, 
            40, window.innerHeight, 
            { isStatic: true, render: { visible: false } }
        );
        
        const rightWall = Matter.Bodies.rectangle(
            window.innerWidth, window.innerHeight/2, 
            40, window.innerHeight, 
            { isStatic: true, render: { visible: false } }
        );
        
        const ceiling = Matter.Bodies.rectangle(
            window.innerWidth/2, 50,
            window.innerWidth, 10,
            { isStatic: true, render: { visible: false } }
        );

        Matter.World.add(this.world, [ground, leftWall, rightWall, ceiling]);
    }

    setupEvents() {
        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            this.render.canvas.width = window.innerWidth;
            this.render.canvas.height = window.innerHeight;
        });

        // é¼ æ ‡/è§¦æ‘¸äº‹ä»¶
        const canvas = this.render.canvas;
        canvas.addEventListener('mousedown', (e) => {
            this.clickCount++;
            this.createFruit(e);
            this.updateStats();
        });
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.clickCount++;
            this.createFruit(e.touches[0]);
            this.updateStats();
        });

        // ç¢°æ’äº‹ä»¶
        Matter.Events.on(this.engine, 'collisionStart', (event) => {
            event.pairs.forEach((pair) => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                
                if (bodyA.fruitType !== undefined && 
                    bodyB.fruitType !== undefined &&
                    bodyA.fruitType === bodyB.fruitType) {
                    this.mergeFruits(bodyA, bodyB);
                }
            });
        });
    }

    updateStats() {
        document.getElementById('score').textContent = this.score;
        document.getElementById('clickCount').textContent = this.clickCount;
        document.getElementById('currentLevel').textContent = this.currentLevel;
        document.getElementById('targetScore').textContent = this.targetScore;
    }

    updatePreview() {
        const fruit = FRUITS[this.nextFruitType];
        document.getElementById('nextFruitPreview').textContent = fruit.name;
        document.getElementById('nextFruitPreview').style.color = fruit.color;
    }

    getNextFruitType() {
        if (this.maxFruitLevel < 3) return 0;
        const minLevel = Math.max(0, this.maxFruitLevel - 3);
        return Math.floor(Math.random() * (this.maxFruitLevel - minLevel + 1)) + minLevel;
    }

    createFruit(event) {
        if(this.gameOver) return;
        
        // ä½¿ç”¨å½“å‰é¢„è§ˆçš„æ°´æœç±»å‹ç”Ÿæˆæ°´æœ
        const type = this.nextFruitType;
        const fruit = FRUITS[type];
        
        const newFruit = Matter.Bodies.circle(
            event.clientX, 
            100, 
            fruit.radius,
            {
                restitution: 0.2,
                friction: 0.5,
                render: {
                    fillStyle: fruit.color,
                    text: {
                        content: fruit.name,
                        color: '#fff',
                        size: fruit.radius,
                        family: 'Arial'
                    }
                },
                fruitType: type
            }
        );
        
        Matter.World.add(this.world, newFruit);
        
        // ç”Ÿæˆä¸‹ä¸€ä¸ªæ°´æœçš„ç±»å‹å¹¶æ›´æ–°é¢„è§ˆ
        this.nextFruitType = this.getNextFruitType();
        this.updatePreview();
    }

mergeFruits(bodyA, bodyB) {
    const type = bodyA.fruitType;
    if (type >= FRUITS.length - 1) { // å¦‚æœåˆæˆçš„æ˜¯æœ€é«˜æ°´æœï¼ˆå¤§è¥¿ç“œï¼‰
        // æ£€æŸ¥åˆ†æ•°æ˜¯å¦è¾¾åˆ°ç›®æ ‡åˆ†æ•°
        if (this.score >= this.targetScore) {
            this.showLevelComplete(); // å¦‚æœè¾¾åˆ°ç›®æ ‡åˆ†æ•°ï¼Œæ˜¾ç¤ºæœ¬å…³é€šå…³
        } else {
            this.showGameOver(false); // å¦‚æœæœªè¾¾åˆ°ç›®æ ‡åˆ†æ•°ï¼Œæ¸¸æˆå¤±è´¥
        }
        return;
    }

    // ç§»é™¤æ—§ç‰©ä½“
    Matter.World.remove(this.world, [bodyA, bodyB]);
    
    // åˆ›å»ºæ–°æ°´æœ
    const newType = type + 1;
    this.maxFruitLevel = Math.max(this.maxFruitLevel, newType);
    
    const newFruit = Matter.Bodies.circle(
        (bodyA.position.x + bodyB.position.x) / 2,
        (bodyA.position.y + bodyB.position.y) / 2,
        FRUITS[newType].radius,
        {
            restitution: 0.2,
            friction: 0.5,
            render: {
                fillStyle: FRUITS[newType].color,
                text: {
                    content: FRUITS[newType].name,
                    color: '#fff',
                    size: FRUITS[newType].radius,
                    family: 'Arial'
                }
            },
            fruitType: newType
        }
    );
    
    // æ·»åŠ åˆ†æ•°
    this.score += FRUITS[newType].score;
    this.updateStats();

    Matter.World.add(this.world, newFruit);
}

nextLevel() {
    this.currentLevel++; // è¿›å…¥ä¸‹ä¸€å…³
    this.score = 0; // æ¸…ç©ºå½“å‰åˆ†æ•°
    this.targetScore += 60; // å¢åŠ ç›®æ ‡åˆ†æ•°
    this.updateStats(); // æ›´æ–°UIæ˜¾ç¤º

    // æ£€æŸ¥æ˜¯å¦é€šå…³
    if (this.currentLevel > 10) {
        this.showGameOver(true); // å¦‚æœè¶…è¿‡10å…³ï¼Œæ˜¾ç¤ºé€šå…³æç¤º
    } else {
        this.gameOver = false; // é‡æ–°å¼€å§‹æ¸¸æˆ
        document.querySelector('.game-over').remove(); // ç§»é™¤é€šå…³æç¤º
    }
}
    
showLevelComplete() {
    this.gameOver = true; // æš‚åœæ¸¸æˆ
    const levelCompleteOverlay = document.createElement('div');
    levelCompleteOverlay.className = 'game-over';
    levelCompleteOverlay.innerHTML = `
        <h2>æœ¬å…³é€šå…³ï¼</h2>
        <p>å½“å‰å…³å¡ï¼š${this.currentLevel}</p>
        <p>å½“å‰å¾—åˆ†ï¼š${this.score}</p>
        <button id="nextLevelButton">è¿›å…¥ä¸‹ä¸€å…³</button>
    `;
    document.body.appendChild(levelCompleteOverlay);

    // æ·»åŠ æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    const nextLevelButton = document.getElementById('nextLevelButton');
    nextLevelButton.addEventListener('click', () => {
        this.nextLevel(); // è¿›å…¥ä¸‹ä¸€å…³
    });
}
    
levelUp() {
    this.currentLevel++; // è¿›å…¥ä¸‹ä¸€å…³
    this.targetScore += 60; // å¢åŠ ç›®æ ‡åˆ†æ•°
    this.updateStats(); // æ›´æ–°UIæ˜¾ç¤º

    // æ£€æŸ¥æ˜¯å¦é€šå…³
    if (this.currentLevel > 10) {
        this.showGameOver(true); // å¦‚æœè¶…è¿‡10å…³ï¼Œæ˜¾ç¤ºé€šå…³æç¤º
    }
}

showGameOver(success) {
    this.gameOver = true;
    document.getElementById('finalScore').textContent = this.score;
    document.getElementById('finalClickCount').textContent = this.clickCount;
    document.getElementById('gameOver').style.display = 'block';

    if (success) {
        document.getElementById('gameOverText').textContent = 'æ­å–œé€šå…³ï¼';
        // ä¿å­˜é€šå…³è®°å½•
        localStorage.setItem('scoreModeLevel', this.currentLevel);
    } else {
        document.getElementById('gameOverText').textContent = 'æ¸¸æˆå¤±è´¥ï¼Œå†æ¥å†å‰ï¼';
    }
}

// å¯åŠ¨æ¸¸æˆ
new ScoreModeGame();
</script>
</body>
</html>
