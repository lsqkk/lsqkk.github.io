<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>光的反射 - 夸克 Physics</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 10px;
        }

        .description {
            text-align: center;
            margin-bottom: 20px;
            color: #7f8c8d;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .canvas-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 15px;
            position: relative;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background-color: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 15px;
        }

        .control-group {
            flex: 1;
            min-width: 200px;
        }

        h2 {
            font-size: 1.2em;
            margin-top: 0;
            color: #3498db;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            padding: 8px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #2980b9;
        }

        button.reset {
            background-color: #e74c3c;
        }

        button.reset:hover {
            background-color: #c0392b;
        }

        .info-panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 15px;
        }

        .info-item {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }

        .info-label {
            font-weight: bold;
            color: #2c3e50;
        }

        .info-value {
            color: #3498db;
        }

        .instructions {
            background: #e8f4fc;
            border-left: 4px solid #3498db;
            padding: 10px 15px;
            margin-top: 15px;
            border-radius: 0 4px 4px 0;
        }

        .instructions h3 {
            margin-top: 0;
            color: #2c3e50;
        }

        .instructions ul {
            margin: 5px 0;
            padding-left: 20px;
        }

        .instructions li {
            margin: 5px 0;
        }
    </style>
</head>

<body>
    <h1>光的反射定律演示</h1>
    <p class="description">通过交互式动画理解光的反射原理：入射角等于反射角</p>

    <div class="container">
        <div class="canvas-container">
            <canvas id="reflectionCanvas" width="800" height="500"></canvas>
        </div>

        <div class="controls">
            <div class="control-group">
                <h2>光源控制</h2>
                <div class="button-group">
                    <button id="addLight">添加新光源</button>
                    <button id="removeLight">移除光源</button>
                </div>
                <p>拖动光源改变位置，拖动光线末端改变方向</p>
            </div>

            <div class="control-group">
                <h2>反射面控制</h2>
                <div class="button-group">
                    <button id="addMirror">添加新反射面</button>
                    <button id="removeMirror">移除反射面</button>
                </div>
                <p>拖动反射面两端调整位置和角度</p>
            </div>

            <div class="control-group">
                <h2>动画控制</h2>
                <div class="button-group">
                    <button id="toggleAnimation">暂停动画</button>
                    <button class="reset" id="resetAll">重置所有</button>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <h2>物理信息</h2>
            <div class="info-item">
                <span class="info-label">入射角:</span>
                <span class="info-value" id="incidentAngle">30°</span>
            </div>
            <div class="info-item">
                <span class="info-label">反射角:</span>
                <span class="info-value" id="reflectionAngle">30°</span>
            </div>
            <div class="info-item">
                <span class="info-label">反射定律:</span>
                <span class="info-value">入射角 = 反射角</span>
            </div>

            <div class="instructions">
                <h3>操作说明</h3>
                <ul>
                    <li>拖动光源位置可以改变光线起点</li>
                    <li>拖动光线末端可以改变光线方向</li>
                    <li>拖动反射面两端可以调整反射面位置和角度</li>
                    <li>只有反射面正面（蓝色）能反射光线</li>
                    <li>可以添加多个光源和反射面</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // 获取Canvas和上下文
        const canvas = document.getElementById('reflectionCanvas');
        const ctx = canvas.getContext('2d');

        // 状态变量
        let animationId = null;
        let isAnimating = true;
        let selectedObject = null;
        let dragHandle = null;

        // 物理参数
        const lightSpeed = 2;

        // 初始数据
        let mirrors = [
            {
                x2: 150, y2: 300,
                x1: 650, y1: 300,
                color: '#3498db',
                backColor: '#95a5a6'
            }
        ];

        let lights = [
            {
                x: 200, y: 200,
                directionX: 300, directionY: 250,
                color: '#e74c3c',
                rayProgress: 0
            }
        ];

        // 计算两点之间的距离
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        // 计算线段与光线的交点
        function findIntersection(light, mirror) {
            const x1 = light.x;
            const y1 = light.y;
            const x2 = light.directionX;
            const y2 = light.directionY;
            const x3 = mirror.x1;
            const y3 = mirror.y1;
            const x4 = mirror.x2;
            const y4 = mirror.y2;

            const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

            if (denominator === 0) {
                return null; // 平行，无交点
            }

            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;

            if (t >= 0 && u >= 0 && u <= 1) {
                return {
                    x: x1 + t * (x2 - x1),
                    y: y1 + t * (y2 - y1),
                    t: t
                };
            }

            return null;
        }

        // 计算反射光线
        function calculateReflection(light, mirror, intersection) {
            // 计算镜面的法线向量
            const dx = mirror.x2 - mirror.x1;
            const dy = mirror.y2 - mirror.y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            const nx = -dy / length;
            const ny = dx / length;

            // 计算入射向量
            const ix = intersection.x - light.x;
            const iy = intersection.y - light.y;
            const ilength = Math.sqrt(ix * ix + iy * iy);
            const invIx = ix / ilength;
            const invIy = iy / ilength;

            // 计算反射向量
            const dot = invIx * nx + invIy * ny;
            const rx = invIx - 2 * dot * nx;
            const ry = invIy - 2 * dot * ny;

            // 返回反射光线的终点
            return {
                x: intersection.x + rx * 300,
                y: intersection.y + ry * 300
            };
        }

        // 判断点是否在镜子的正面
        function isOnFrontSide(point, mirror) {
            const dx = mirror.x2 - mirror.x1;
            const dy = mirror.y2 - mirror.y1;
            const nx = -dy;
            const ny = dx;

            const px = point.x - mirror.x1;
            const py = point.y - mirror.y1;

            return (px * nx + py * ny) >= 0;
        }

        // 绘制场景
        function draw() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 绘制网格背景
            drawGrid();

            // 绘制所有反射面
            mirrors.forEach(mirror => {
                drawMirror(mirror);
            });

            // 绘制所有光源和光线
            lights.forEach(light => {
                drawLight(light);
            });

            // 更新角度信息
            updateAngleInfo();
        }

        // 绘制网格背景
        function drawGrid() {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;

            // 垂直线
            for (let x = 0; x <= canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            // 水平线
            for (let y = 0; y <= canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // 绘制反射面
        function drawMirror(mirror) {
            // 绘制背面（灰色）
            ctx.strokeStyle = mirror.backColor;
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(mirror.x1, mirror.y1);
            ctx.lineTo(mirror.x2, mirror.y2);
            ctx.stroke();

            // 绘制正面（蓝色）
            ctx.strokeStyle = mirror.color;
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(mirror.x1, mirror.y1);
            ctx.lineTo(mirror.x2, mirror.y2);
            ctx.stroke();

            // 绘制端点控制点
            ctx.fillStyle = mirror.color;
            ctx.beginPath();
            ctx.arc(mirror.x1, mirror.y1, 6, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(mirror.x2, mirror.y2, 6, 0, Math.PI * 2);
            ctx.fill();
        }

        // 绘制光源和光线
        function drawLight(light) {
            // 绘制光源
            ctx.fillStyle = light.color;
            ctx.beginPath();
            ctx.arc(light.x, light.y, 8, 0, Math.PI * 2);
            ctx.fill();

            // 绘制光线方向控制点
            ctx.fillStyle = '#f39c12';
            ctx.beginPath();
            ctx.arc(light.directionX, light.directionY, 6, 0, Math.PI * 2);
            ctx.fill();

            // 计算光线与所有镜子的交点
            let closestIntersection = null;
            let closestMirror = null;

            mirrors.forEach(mirror => {
                const intersection = findIntersection(light, mirror);
                if (intersection && (!closestIntersection || intersection.t < closestIntersection.t)) {
                    closestIntersection = intersection;
                    closestMirror = mirror;
                }
            });

            // 绘制入射光线
            ctx.strokeStyle = light.color;
            ctx.lineWidth = 2;
            ctx.setLineDash([]);

            if (closestIntersection) {
                // 绘制入射光线（从光源到交点）
                ctx.beginPath();
                ctx.moveTo(light.x, light.y);
                ctx.lineTo(closestIntersection.x, closestIntersection.y);
                ctx.stroke();

                // 检查是否在反射面正面
                if (isOnFrontSide({ x: light.x, y: light.y }, closestMirror)) {
                    // 计算并绘制反射光线
                    const reflection = calculateReflection(light, closestMirror, closestIntersection);

                    // 绘制反射光线
                    ctx.strokeStyle = '#9b59b6';
                    ctx.beginPath();
                    ctx.moveTo(closestIntersection.x, closestIntersection.y);
                    ctx.lineTo(reflection.x, reflection.y);
                    ctx.stroke();

                    // 绘制法线
                    const dx = closestMirror.x2 - closestMirror.x1;
                    const dy = closestMirror.y2 - closestMirror.y1;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const nx = -dy / length;
                    const ny = dx / length;

                    ctx.strokeStyle = '#2ecc71';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(closestIntersection.x, closestIntersection.y);
                    ctx.lineTo(
                        closestIntersection.x + nx * 40,
                        closestIntersection.y + ny * 40
                    );
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // 绘制角度标注
                    drawAngleAnnotation(light, closestMirror, closestIntersection);
                }
            } else {
                // 没有交点，直接绘制完整光线
                ctx.beginPath();
                ctx.moveTo(light.x, light.y);
                ctx.lineTo(light.directionX, light.directionY);
                ctx.stroke();
            }
        }

        // 绘制角度标注
        function drawAngleAnnotation(light, mirror, intersection) {
            // 计算镜面的法线向量
            const dx = mirror.x2 - mirror.x1;
            const dy = mirror.y2 - mirror.y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            const nx = -dy / length;
            const ny = dx / length;

            // 计算入射向量
            const ix = intersection.x - light.x;
            const iy = intersection.y - light.y;
            const ilength = Math.sqrt(ix * ix + iy * iy);
            const invIx = ix / ilength;
            const invIy = iy / ilength;

            // 计算入射角
            const dot = invIx * nx + invIy * ny;
            const incidentAngle = Math.acos(Math.abs(dot)) * 180 / Math.PI;

            // 绘制入射角标注
            const angleRadius = 25;
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 1.5;
            ctx.beginPath();

            // 计算起始和结束角度
            const startAngle = Math.atan2(ny, nx);
            const endAngle = Math.atan2(-invIy, -invIx);

            ctx.arc(intersection.x, intersection.y, angleRadius, startAngle, endAngle, true);
            ctx.stroke();

            // 绘制反射角标注
            const reflectionAngle = incidentAngle; // 根据反射定律

            ctx.strokeStyle = '#9b59b6';
            ctx.beginPath();

            // 计算反射向量的角度
            const rx = invIx - 2 * dot * nx;
            const ry = invIy - 2 * dot * ny;
            const reflectionEndAngle = Math.atan2(ry, rx);

            ctx.arc(intersection.x, intersection.y, angleRadius, startAngle, reflectionEndAngle);
            ctx.stroke();

            // 更新角度显示
            document.getElementById('incidentAngle').textContent = incidentAngle.toFixed(1) + '°';
            document.getElementById('reflectionAngle').textContent = reflectionAngle.toFixed(1) + '°';
        }

        // 更新角度信息
        function updateAngleInfo() {
            // 在drawLight中已经更新了角度信息
        }

        // 动画循环
        function animate() {
            if (isAnimating) {
                lights.forEach(light => {
                    light.rayProgress += lightSpeed;
                    if (light.rayProgress > 100) {
                        light.rayProgress = 0;
                    }
                });
            }

            draw();
            animationId = requestAnimationFrame(animate);
        }

        // 检查点是否在对象上
        function getObjectAtPoint(x, y) {
            // 检查是否在光源上
            for (let i = 0; i < lights.length; i++) {
                const light = lights[i];
                if (distance(x, y, light.x, light.y) < 15) {
                    return { type: 'light', index: i, handle: 'source' };
                }
                if (distance(x, y, light.directionX, light.directionY) < 10) {
                    return { type: 'light', index: i, handle: 'direction' };
                }
            }

            // 检查是否在反射面端点上
            for (let i = 0; i < mirrors.length; i++) {
                const mirror = mirrors[i];
                if (distance(x, y, mirror.x1, mirror.y1) < 10) {
                    return { type: 'mirror', index: i, handle: 'end1' };
                }
                if (distance(x, y, mirror.x2, mirror.y2) < 10) {
                    return { type: 'mirror', index: i, handle: 'end2' };
                }
            }

            return null;
        }

        // 事件处理
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            selectedObject = getObjectAtPoint(x, y);
            dragHandle = selectedObject ? selectedObject.handle : null;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!selectedObject) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (selectedObject.type === 'light') {
                const light = lights[selectedObject.index];
                if (dragHandle === 'source') {
                    light.x = x;
                    light.y = y;
                } else if (dragHandle === 'direction') {
                    light.directionX = x;
                    light.directionY = y;
                }
            } else if (selectedObject.type === 'mirror') {
                const mirror = mirrors[selectedObject.index];
                if (dragHandle === 'end1') {
                    mirror.x1 = x;
                    mirror.y1 = y;
                } else if (dragHandle === 'end2') {
                    mirror.x2 = x;
                    mirror.y2 = y;
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            selectedObject = null;
            dragHandle = null;
        });

        canvas.addEventListener('mouseleave', () => {
            selectedObject = null;
            dragHandle = null;
        });

        // 按钮事件处理
        document.getElementById('addLight').addEventListener('click', () => {
            lights.push({
                x: 100 + Math.random() * 100,
                y: 100 + Math.random() * 100,
                directionX: 200 + Math.random() * 100,
                directionY: 200 + Math.random() * 100,
                color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                rayProgress: 0
            });
        });

        document.getElementById('removeLight').addEventListener('click', () => {
            if (lights.length > 1) {
                lights.pop();
            }
        });

        document.getElementById('addMirror').addEventListener('click', () => {
            const x = 200 + Math.random() * 400;
            const y = 200 + Math.random() * 200;
            const angle = Math.random() * Math.PI;
            const length = 100 + Math.random() * 150;

            mirrors.push({
                x1: x - Math.cos(angle) * length / 2,
                y1: y - Math.sin(angle) * length / 2,
                x2: x + Math.cos(angle) * length / 2,
                y2: y + Math.sin(angle) * length / 2,
                color: `hsl(${Math.random() * 360}, 70%, 50%)`,
                backColor: '#95a5a6'
            });
        });

        document.getElementById('removeMirror').addEventListener('click', () => {
            if (mirrors.length > 1) {
                mirrors.pop();
            }
        });

        document.getElementById('toggleAnimation').addEventListener('click', () => {
            isAnimating = !isAnimating;
            document.getElementById('toggleAnimation').textContent =
                isAnimating ? '暂停动画' : '继续动画';
        });

        document.getElementById('resetAll').addEventListener('click', () => {
            mirrors = [
                {
                    x1: 150, y1: 300,
                    x2: 650, y2: 300,
                    color: '#3498db',
                    backColor: '#95a5a6'
                }
            ];

            lights = [
                {
                    x: 100, y: 200,
                    directionX: 400, directionY: 250,
                    color: '#e74c3c',
                    rayProgress: 0
                }
            ];

            isAnimating = true;
            document.getElementById('toggleAnimation').textContent = '暂停动画';
        });

        // 启动动画
        animate();
    </script>
</body>

</html>